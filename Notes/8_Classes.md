### **CS106L 课程笔记：第8讲 - 类与继承**

**学术助理:** Fabio Ibanez, Jacob Roberts-Baca (根据幻灯片)
**主题:** 本讲座深入探讨了C++的核心支柱——**类 (Class)** 和 **继承 (Inheritance)**。我们从类的基本概念、设计原则出发，逐步深入到继承、多态，最终探讨了多重继承中复杂的“菱形问题”及其解决方案。本讲座充分展示了C++语言的强大性与设计深度。

---

### **第一部分：为什么需要类？从C到C++的跃升**

1.  **C语言的局限性**
    *   **无对象 (No Objects):** C是过程式语言，缺乏“对象”这一基本概念。
    *   **无封装 (No Encapsulation):** 无法将数据和操作该数据的函数捆绑成一个独立的逻辑单元。
    *   **无面向对象设计模式 (No OOP):** 无法应用封装、继承、多态等强大的设计模式。

2.  **什么是面向对象编程 (OOP)?**
    *   OOP的核心是**对象 (Objects)**。
    *   它关注于**类 (Classes)** 的设计与实现。
    *   **类**是用户自定义的类型，是创建对象的蓝图。

3.  **`struct` 与 `class` 的对比**
    *   根据C++之父Bjarne Stroustrup的定义，两者本质上非常相似。
    *   **核心区别在于默认访问权限**：
        *   `class` 成员**默认为 `private`** (私有)。
        *   `struct` 成员**默认为 `public`** (公有)。
    *   因此，可以说 `struct` 是一种默认访问权限开放的 `class`。在实践中，我们通常用 `class` 来表示包含复杂行为和数据保护的对象，用 `struct` 来表示纯粹的数据聚合体。

---

### **第二部分：类的设计与实现**

一个设计良好的类，其生命周期和行为由以下几个关键部分定义：

#### **2.1 类的四大基本组成**

1.  **构造函数 (Constructor):** 对象创建时自动调用，用于初始化成员变量，确保对象处于一个有效的初始状态。
2.  **析构函数 (Destructor):** 对象销毁时自动调用，用于释放资源（如动态分配的内存），防止内存泄漏。
3.  **公共成员 (Public Members):** 构成类的**公共接口**，是外部代码与对象交互的唯一合法途径。
4.  **私有成员 (Private Members):** 类的内部实现细节，外部无法访问，实现了**封装**和**信息隐藏**，保护了数据的完整性。

#### **2.2 接口与实现分离：`.h` 与 `.cpp` 文件**

这是C++项目组织的核心原则，将“声明”与“实现”分开。

| 文件类型           | 目的              | 包含内容               | 使用方式                    |
| :------------- | :-------------- | :----------------- | :---------------------- |
| **头文件 (.h)**   | **定义接口** (What) | 函数原型、类声明、类型别名、宏、常量 | 通过 `#include` 在多个源文件中共享 |
| **源文件 (.cpp)** | **实现功能** (How)  | 函数和方法的具体代码实现       | 被编译器独立编译成目标文件(.o/.obj)  |

**编译与链接流程**:
1.  **编译时**: 预处理器将 `#include` 的 `.h` 文件内容“粘贴”到 `.cpp` 文件中，让编译器知道存在哪些函数和类（接口）。编译器据此生成目标文件，对未实现的函数调用留下“标记”。
2.  **链接时**: 链接器收集所有目标文件，根据“标记”去寻找函数的具体实现，将它们连接起来，最终生成一个可执行文件。

#### **2.3 深入构造函数 (Constructor)**

*   **参数化构造函数:** 接受参数以定制化地创建对象。
*   **常见陷阱：参数遮蔽 (Shadowing):** 如果构造函数参数名与成员变量名相同，直接赋值 (`name = name;`) 会导致无效的自我赋值。
    *   **解决方案1: `this` 指针:** `this->name = name;` 明确指定赋值目标是类的成员。
    *   **解决方案2 (首选): 成员初始化列表:** `ClassName(int val) : member(val) {}`。这种方式在函数体执行前就完成初始化，更高效，且对于 `const` 或引用成员是必须的。
*   **默认构造函数:** 不接受任何参数的构造函数。如果你不写任何构造函数，编译器会为你生成一个。
*   **构造函数重载 (Overload):** 一个类可以有多个构造函数（参数不同），编译器会根据你提供的参数自动选择合适的版本。

#### **2.4 内联函数 (Inline Functions)**

*   **为什么有些函数直接在 `.h` 文件中实现？**
    *   当在类的定义内部实现一个成员函数时，编译器会视其为**内联 (inline)** 请求。
    *   对于简短、频繁调用的函数（如 `area()`），内联可以避免函数调用的开销，提高效率。
    *   这是将实现写在头文件中的一个常见且合理的例外情况。

#### **2.5 常用类型：`size_t` 和 `bool`**

*   **`size_t`**: 一个**无符号整数**类型别名，用于表示对象大小或数组索引。它的关键优势是**可移植性**，在任何平台（32/64位）都保证足够大，能避免溢出。标准库中所有与大小相关的操作都使用它。
*   **`bool`**: 表示逻辑**真 (`true`)** 或**假 (`false`)** 的基本类型。它提供了**类型安全**和**可读性**，是所有逻辑运算和条件判断的基础。

---

### **第三部分：继承 (Inheritance)**

继承用于建立类之间的 **“是一个 (is-a)”** 关系，是代码复用和抽象的关键。

#### **3.1 继承的两大优势**

1.  **可扩展性 (Extensibility):** 子类可以复用父类的代码，并添加自己特有的属性和方法。
2.  **动态多态 (Dynamic Polymorphism):** 允许通过基类的指针或引用来操作不同的派生类对象，在运行时自动调用各自版本的函数。

#### **3.2 实现继承与多态**

*   **虚函数 (Virtual Function):** 在基类函数前加 `virtual` 关键字，表示该函数支持多态，其行为可在派生类中被**重写 (override)**。
*   **纯虚函数与抽象基类 (ABC):**
    *   `virtual double area() const = 0;` 这种 `= 0` 的语法定义了一个**纯虚函数**。
    *   任何包含纯虚函数的类都是一个**抽象基类**，它**不能被实例化**（不能创建对象）。
    *   抽象基类的作用是定义一个**接口契约**，强制所有派生类必须实现该函数。
*   **`override` 关键字:** 在派生类中重写虚函数时使用，是一个安全检查。如果函数签名与基类不匹配，编译器会报错。
*   **`const` 成员函数:** `double area() const;`，函数末尾的 `const` 承诺该函数**不会修改**调用它的对象的状态。这是“只读”操作的标志，也是良好编程实践的一部分。

#### **3.3 继承的访问控制**

继承时使用的 `public`, `protected`, `private` 关键字，决定了基类成员在派生类中的**访问权限上限**。

| 基类 `A` 成员 | `class B : public A` | `class B : protected A` | `class B : private A` |
| :--- | :--- | :--- | :--- |
| `public` | `public` | `protected` | `private` |
| `protected` | `protected` | `protected` | `private` |
| `private` | (不可访问) | (不可访问) | (不可访问) |

*   **`protected` 成员**: 只能被本类和其所有派生类访问，但不能被外部访问。它为派生类提供了一个受保护的扩展点。

---

### **第四部分：多重继承与菱形问题**

*   **多重继承 (Multiple Inheritance):** 一个类可以同时继承自多个基类，如 `class SectionLeader : public Person, public Employee`。这允许一个对象拥有多种身份。
*   **菱形问题 (The Diamond Problem):**
    *   当一个类（`SectionLeader`）通过两条不同的路径继承自同一个远端基类（`Person`）时，会导致该基类的成员在最终派生类中出现**两份拷贝**，从而产生数据冗余和访问**二义性**。
    *   **解决方案：虚继承 (Virtual Inheritance):**
        *   在中间类（`Student`, `Employee`）继承顶层基类时使用 `virtual` 关键字：`class Student : public virtual Person`。
        *   这能确保最终派生类中只包含**一个共享**的顶层基类实例。
    *   **虚继承的特殊规则：**
        *   初始化共享虚基类的责任**必须由最终派生类（`SectionLeader`）承担**。在 `SectionLeader` 的构造函数初始化列表中，必须显式调用 `Person` 的构造函数。

---

### **课程总结 (Recap)**

1.  **封装**: 类通过访问控制（`public`, `private`）将数据和功能打包，实现了信息隐藏和数据保护。
2.  **继承与抽象**: 继承通过虚函数和抽象类，让我们能够设计出强大、灵活的抽象，以模拟真实世界的复杂关系，并实现动态多态。
3.  **C++的强大与复杂**: 本讲座所涵盖的概念（尤其是多重继承和菱形问题）虽然棘手，但它们正是C++强大表达能力和底层控制能力的体现，使其在构建高性能复杂系统时依然是首选语言。
### **CS106L 课程笔记：第三讲 - 初始化、引用与编译基础**

**课程核心：本讲深入探讨了 C++ 中如何创建和使用变量，重点关注如何以更安全、更现代的方式进行初始化，并详细剖析了引用的强大功能及其常见陷阱。最后，课程介绍了基本的 C++ 编译流程。**

---

#### **1. 变量初始化 (Initialization)**

初始化是在创建变量时赋予其初始值的过程，是保证代码健壮性的第一步。课程介绍了三种主要的初始化方法：

##### **1.1. 直接初始化 (Direct Initialization)**

*   **语法**: 使用圆括号 `()`，例如 `int x(10);`。
*   **核心问题**: **不安全**。它允许可能导致数据丢失的 **“窄化转换” (narrowing conversion)**，并且编译器默认不会报错。
*   **关键案例 (反应堆问题)**:
    ```cpp
    int criticalTemperature(100.8); // 程序员意图是100.8
    ```
    实际上 `criticalTemperature` 的值因窄化转换（浮点数转整数，小数被截断）而变为 `100`，导致 `if (temperature > 100.0)` 的判断逻辑失败，引发了潜在的严重 bug。

##### **1.2. 统一初始化 (Uniform Initialization) - (C++11, 推荐使用)**

*   **语法**: 使用花括号 `{}`，例如 `int x{10};`。
*   **核心优势**:
    1.  **安全 (Safe)**: **禁止**窄化转换。任何可能导致数据丢失的初始化尝试都会直接导致**编译时错误**，将潜在的运行时 bug 扼杀在摇篮里。
        ```cpp
        int num{12.0}; // 编译失败！error: type 'double' cannot be narrowed to 'int'
        ```
    2.  **普遍适用 (Ubiquitous)**: 语法一致，适用于几乎所有类型，包括基础类型、STL容器（`vector`, `map`等）和自定义类，让代码风格更统一。
        ```cpp
        std::vector<int> v{1, 2, 3};
        std::map<std::string, int> ages{{"Alice", 25}, {"Bob", 30}};
        ```

##### **1.3. 结构化绑定 (Structured Binding) - (C++17)**

*   **语法**: `auto [var1, var2] = object;`
*   **功能**: 一种便捷的初始化方式，用于从 `struct`、`pair`、`tuple` 等固定大小的结构中“解包”成员到独立的变量中。
    ```cpp
    std::tuple<std::string, std::string> getClassInfo() { return {"CS106L", "C++"}; }
    auto [className, language] = getClassInfo(); // className="CS106L", language="C++"
    ```

---

#### **2. 引用 (References)**

引用是 C++ 中一个极其重要的概念，它为已存在的变量提供了别名。

##### **2.1. 核心概念**

*   **引用即别名 (Alias)**: 引用不是对象的副本，而是指向与原始变量完全相同的内存地址的另一个名字。
*   **声明语法**: 使用 `&` 符号，例如 `int& ref = original_var;`。
*   **关键行为**: 修改引用就等于修改原始变量。

##### **2.2. 按引用传递 (Pass-by-Reference)**

这是引用最核心的应用，允许函数直接修改传入的参数。

*   **对比**:
    *   **按值传递 `(int n)`**: 函数内得到的是一个副本，修改副本不影响外部。
    *   **按引用传递 `(int& n)`**: 函数内得到的是一个别名，修改别名会直接修改外部的原始变量。

##### **2.3. 经典陷阱：引用-拷贝 Bug**

在范围 `for` 循环中，如果不加注意，即使容器本身是按引用传递的，循环变量也可能只是元素的副本。

*   **错误代码**:
    ```cpp
    // 意图：将向量中每个 pair 的值都加一
    for (auto [num1, num2] : nums) { // 此处 auto 创建了元素的副本
        num1++; num2++; // 修改的是副本，原始 nums 未受影响
    }
    ```
*   **正确修复**:
    > **在 `auto` 后面加上 `&`，确保循环变量也是引用。**
    ```cpp
    for (auto& [num1, num2] : nums) { // auto& 获取元素的引用
        num1++; num2++; // 现在修改的是原始数据
    }
    ```

---

#### **3. 左值 (L-values) vs. 右值 (R-values)**

这是一个更深层次的概念，与引用的使用密切相关。

*   **简易理解**:
    *   **左值**: 可以出现在赋值运算符 `=` 左边的东西，通常是有持久内存地址的变量。
    *   **右值**: 只能出现在 `=` 右边的东西，通常是临时的字面量或表达式结果（如 `10`, `x + y`）。
*   **关键规则**:
    > **非 `const` 的左值引用 (如 `int&`) 不能绑定到右值。**
*   **痛点实例**:
    ```cpp
    void squareN(int& n) { /* ... */ }
    squareN(5); // 编译失败！
    ```
    因为 `5` 是一个右值（临时值），而函数 `squareN` 的参数 `int& n` 要求一个左值（一个有地址的变量）作为输入。

---

#### **4. 常量正确性 (Const Correctness)**

`const` 是一个承诺，保证变量不可被修改，是编写安全、可靠代码的基石。

*   **基本功能**: `const int PI = 3.14;` 声明一个不可修改的常量。
*   **与引用的结合**:
    > **核心规则：权限可以降低，但不能提升。**
    1.  **禁止权限提升 (错误)**: 你**不能**用一个非 `const` 的引用去指向一个 `const` 变量。这相当于试图通过别名绕过原始变量的只读保护。
        ```cpp
        const int x = 10;
        int& ref = x; // 编译失败！试图获取可写权限
        ```
    2.  **允许权限降低 (正确)**: 你**可以**用一个 `const` 的引用去指向一个非 `const` 变量。这相当于为这个变量创建了一个“只读视图”，是完全安全的。
        ```cpp
        int y = 20;
        const int& ref = y; // 完全合法！通过 ref 不能修改 y，但可以直接修改 y
        // ref = 30; // 错误！
        // y = 30;   // 正确！
        ```
    *   **最佳实践**: 在函数参数中，对于只读的大对象，使用 `const` 引用 (`const std::string&`) 是最高效和最安全的方式。

---

#### **5. 编译 C++ 程序 (Compiling)**

*   **基本概念**: C++ 是编译型语言，源代码 (`.cpp`) 需通过**编译器**（如 `g++` 或 `clang`）翻译成机器能执行的文件。
*   **基本编译命令解析**:
    `g++ -std=c++23 main.cpp -o main`
    *   `g++`: 调用编译器。
    *   `-std=c++23`: 指定使用 C++23 语言标准。
    *   `main.cpp`: 输入的源文件名。
    *   `-o main`: 指定输出的可执行文件名为 `main` (o for output)。

---
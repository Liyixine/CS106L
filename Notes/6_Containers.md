### **课程笔记：CS106L 第 6 讲 - C++ 容器**

**日期：** 2025 年春季

#### **1. 本讲目标**

今天的课程将超越基础的斯坦福 C++ 库，深入探讨 C++ 标准库中功能强大且应用广泛的**容器**。我们将理解不同容器的优缺点，并学会根据特定需求选择最合适的容器。

#### **2. 核心思想：空间与时间的权衡 (The Space-Time Tradeoff)**

在计算机科学中，我们经常面临一个核心的抉择：是优化程序的运行时间（使其更快）还是优化其内存使用（使其更节省空间）？

*   **类比：整理车库**
    *   **杂乱的车库 (Disorganized Garage)**：就像一个简单的 `std::vector`。把所有东西都堆在一起很**省空间**，因为你不需要额外的架子或标签。但要找一个特定的工具（比如一个扳手）就需要翻遍每一个箱子，**查找起来非常慢**。
    *   **有序的车库 (Organized Garage)**：就像一个 `std::map`。你需要购买架子、储物箱，并给每个箱子贴上标签（如“工具”、“书籍”、“DVD”）。这会占用**更多的空间**（储物系统本身需要空间），但当你需要找东西时，可以根据标签直接定位，**查找速度极快**。

这个比喻揭示了数据结构选择的核心。正如 C++ 的创造者 Bjarne Stroustrup 所言：“空间就是时间 (Space is time)”，有时通过使用更多的内存可以换取程序运行速度的大幅提升。

#### **3. STL：标准模板库 (The Standard Template Library)**

STL 是 C++ 标准库的核心组成部分，它提供了一套通用的模板类和函数，极大地增强了语言的功能。

*   **什么是模板 (Templates)？**
    模板是 C++ 的一个强大功能，它允许我们编写通用的、与类型无关的代码。例如，我们不需要分别为整数、浮点数、字符串编写不同的 `Vector` 类（如 `IntVector`, `DoubleVector`, `StringVector`），而只需编写一个通T用的 `template<typename T> class vector`。在使用时，我们通过 `vector<int>` 或 `vector<string>` 来指定其存储的具体类型。
    **C++ 中所有的标准容器都是模板。**

*   **STL 的组成：**
    STL 主要由四个部分构成，今天我们重点关注**容器**。
    1.  **容器 (Containers)**：用于存储和组织数据的对象（如 `vector`, `map`）。
    2.  **迭代器 (Iterators)**：提供一种统一的方式来遍历容器中的元素。
    3.  **算法 (Algorithms)**：对容器中的数据进行操作的函数（如排序 `sort`、查找 `find`）。
    4.  **函数对象 (Functors)**：行为类似函数的对象。

#### **4. 序列容器 (Sequence Containers)**

序列容器将其元素存储在一个**线性序列**中。

##### **4.1. `std::vector`**

`std::vector` 是 C++ 中最常用、最基础的动态数组。你应该视其为默认的序列容器。

*   **实现方式**：`vector` 在内存中使用一块**连续**的空间来存储其元素。它有两个关键属性：`size`（当前存储的元素数量）和 `capacity`（在不重新分配内存的情况下可以存储的元素总量）。
*   **常用操作**：
    *   `v.push_back(k)`: 在末尾添加元素 `k`。
    *   `v.pop_back()`: 移除末尾的元素。
    *   `v[i]`: 访问索引为 `i` 的元素（**不进行边界检查**）。
    *   `v.at(i)`: 访问索引为 `i` 的元素（**会进行边界检查**，如果越界会抛出异常）。
    *   `v.size()`: 返回元素数量。
    *   `v.clear()`: 清空所有元素。
    *   `v.empty()`: 检查是否为空。

*   **性能特点**：
    *   尾部插入/删除 (`push_back`/`pop_back`)：非常快（均摊 O(1)）。
    *   头部或中部插入/删除：非常慢（O(n)），因为需要移动之后的所有元素。
    *   随机访问：非常快（O(1)），因为内存是连续的。

*   **编程技巧**：
    1.  **使用基于范围的 for 循环**：`for (const auto& elem : my_vector)` 是遍历容器的首选方式，它更简洁、更安全。
    2.  **使用 `const auto&`**：在循环中，这可以避免对每个元素进行不必要的、可能开销巨大的拷贝。
    3.  **理解 `[]` 与 `.at()` 的区别**：为了性能，`[]` 不检查索引是否越界。这遵循了 C++ 的**零开销原则**（You don't pay for what you don't use）。在不确定索引是否有效时，使用 `.at()` 会更安全。

##### **4.2. `std::deque`**

`deque` (发音为 "deck") 的全称是双端队列 (Double-Ended Queue)。

*   **为何需要 `deque`？**
    `vector` 在头部插入元素效率极低。如果你需要一个能在**两端**都进行高效插入和删除操作的容器，`deque` 就是最佳选择。

*   **实现方式**：`deque` 的内存**不是连续的**。它通常由多个小的、连续的内存块（chunks）组成，并通过一个索引结构来管理这些块。这种设计使得在头部和尾部添加或删除元素都无需移动大量数据。

*   **性能特点**：
    *   头部和尾部插入/删除 (`push_front`/`pop_front`, `push_back`/`pop_back`)：非常快（O(1)）。
    *   随机访问：比 `vector` 稍慢，因为需要两次指针解引用，但仍然是 O(1)。
    *   中部插入/删除：仍然很慢（O(n)）。

#### **5. 关联容器 (Associative Containers)**

关联容器根据**键 (key)** 来组织元素，从而实现快速查找。

##### **5.1. `std::map`**

`std::map` 存储键值对 (`key-value` pairs)，其中每个键都是唯一的，并且键是自动排序的。

*   **实现方式**：`std::map` 内部实现为一棵**自平衡二叉搜索树**（通常是红黑树）。这保证了元素总是按键排序，并且查找、插入和删除操作的效率都很高。

*   **性能特点**：所有主要操作（插入、删除、查找）的时间复杂度都是**对数级别 O(log n)**。

*   **关键要求**：`map` 的键类型 `K` **必须定义 `operator<`**，因为树需要这个操作来比较键并维持其有序结构。

*   **常用操作**：
    *   `m[key]`: 访问键 `key` 对应的值。**注意**：如果 `key` 不存在，此操作会**自动插入**一个新的键值对，其中值为该类型的默认值（例如，`int` 的默认值是 0）。
    *   `m.insert({key, value})`: 插入一个键值对。
    *   `m.erase(key)`: 删除指定键的元素。
    *   `m.count(key)`: 检查某个键是否存在（返回 0 或 1）。在 C++20 中，`m.contains(key)` 是更推荐的做法。
    *   遍历：可以使用基于范围的 `for` 循环和结构化绑定来优雅地遍历键值对：
        ```cpp
        for (const auto& [key, value] : my_map) {
            // ... process key and value
        }
        ```

##### **5.2. `std::set`**

`std::set` 存储**唯一的、有序的**元素集合。你可以把它看作是一个只有键、没有值的 `std::map`。

*   **实现与性能**：与 `std::map` 一样，它也基于红黑树实现，所有操作都是 O(log n)。
*   **关键要求**：元素类型 `T` **必须定义 `operator<`**。

##### **5.3. `std::unordered_map` 和 `std::unordered_set`**

这是 `map` 和 `set` 的“另我”(alter ego)。它们提供了与 `map` 和 `set` 几乎完全相同的接口，但具有不同的内部实现和性能特征。

*   **实现方式**：它们都基于**哈希表 (Hash Table)** 实现。数据存储在一系列“桶 (buckets)”中。
    1.  当你插入或查找一个元素时，它的键会被送入一个**哈希函数**，生成一个哈希值。
    2.  这个哈希值随后被用来计算元素应该存放在哪个桶里（通常是 `hash_value % bucket_count`）。
*   **性能特点**：
    *   在理想情况下（哈希函数良好，没有太多冲突），插入、删除和查找操作的平均时间复杂度是**常数级别 O(1)**，这比 `map`/`set` 的 O(log n) 更快。
    *   最坏情况（所有元素都哈希到同一个桶）下，性能会退化到 O(n)。
*   **关键要求**：
    *   键类型 `K` **必须是可哈希的**（即 `std::hash<K>` 必须有定义）。C++ 的基本类型（如 `int`, `double`, `string`）默认都是可哈希的。
    *   键类型 `K` **必须支持相等性比较**（`operator==`）。
*   **Load Factor & Rehashing**：负载因子是指 `元素数量 / 桶的数量`。当负载因子过高时（默认 > 1.0），哈希冲突的概率会增加，性能会下降。此时，`unordered_map` 会进行**rehash**：创建一个更大的桶数组，并重新计算所有元素的位置。

##### **5.4. `map` vs. `unordered_map`：如何选择？**

*   **速度**：`unordered_map` *通常*比 `map` 快。
*   **内存**：`unordered_map` 可能会使用更多的内存来维持较低的负载因子。
*   **排序**：`map` 的键是有序的，而 `unordered_map` 是无序的。如果你需要按顺序遍历元素，只能选择 `map`。
*   **键的要求**：如果你的键类型有自然的排序关系（`operator<`），但定义一个好的哈希函数很困难，那么 `map` 是更好的选择。反之，如果哈希很容易但排序没意义，就用 `unordered_map`。
*   **安全选择**：如果不确定，`std::unordered_map` 是一个很好的现代 C++ 默认选择，因为它通常能提供更好的性能。

#### **6. 总结：数据结构性能一览**

| 容器 | 访问第 i 个元素 | 查找 | 插入 | 删除 | 内存占用 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **`std::vector`** | **非常快 (O(1))** | 慢 (O(n)) | 尾部快，其他慢 | 尾部快，其他慢 | 紧凑 |
| **`std::deque`** | 快 (O(1)) | 慢 (O(n)) | **两端快**，其他慢 | **两端快**，其他慢 | 较低 |
| **`std::set`** | 慢 (O(n)) | **快 (O(log n))** | **快 (O(log n))** | **快 (O(log n))** | 中等 |
| **`std::map`** | 慢 (O(n)) | **快 (O(log n))** | **快 (O(log n))** | **快 (O(log n))** | 中等 |
| **`std::unordered_set`** | 不支持 (N/A) | **非常快 (平均 O(1))** | **非常快 (平均 O(1))** | **非常快 (平均 O(1))**| 较高 |
| **`std::unordered_map`**| 不支持 (N/A) | **非常快 (平均 O(1))** | **非常快 (平均 O(1))** | **非常快 (平均 O(1))**| 较高 |

***

**附录：其他值得了解的容器**
*   `std::array`: 一个**固定大小**的数组，功能上比 C 风格数组更安全、更强大。
*   `std::list`: 一个**双向链表**。在任何位置插入和删除都非常快 (O(1))，但不支持快速随机访问。
*   `std::multiset`/`std::multimap`: 允许存储重复键的 `set` 和 `map`。
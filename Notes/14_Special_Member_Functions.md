### **CS106L 课程笔记：第 14 讲 - 特殊成员函数 (Special Member Functions)**

**课程核心：深入理解 C++ 类的生命周期管理，掌握特殊成员函数的用途、默认行为、重写时机，以及“浅拷贝”与“深拷贝”的区别，最终通向现代 C++ 的“零/三/五法则”设计哲学。**

#### **一、 什么是特殊成员函数 (SMFs)？**

在 C++ 中，每个类都有一组特殊的成员函数，它们控制着该类对象的创建、销-毁、拷贝和移动。即使我们不手动编写，编译器也会在需要时为我们自动生成默认版本。本节课主要聚焦于其中最重要的六个。

**C++ 的六个特殊成员函数：**
1.  **默认构造函数 (Default Constructor):** `T()`
2.  **析构函数 (Destructor):** `~T()`
3.  **拷贝构造函数 (Copy Constructor):** `T(const T&)`
4.  **拷贝赋值运算符 (Copy Assignment Operator):** `T& operator=(const T&)`
5.  **移动构造函数 (Move Constructor):** `T(T&&)` (C++11)
6.  **移动赋值运算符 (Move Assignment Operator):** `T& operator=(T&&)` (C++11)

---

#### **二、 构造函数与初始化 (Construction & Initialization)**

##### **1. 构造函数的基本职责**
构造函数的根本任务是“从无到有”地创建一个有效的对象。一个类可以有多个构造函数，通过不同的参数列表进行重载，以满足不同的初始化需求。
*   `std::vector<int> v1;`  // 调用**默认构造函数**，创建一个空 vector。
*   `std::vector<int> v2(5);` // 调用**带大小参数的构造函数**，创建含 5 个 `0` 的 vector。
*   `std::vector<int> v3(5, 100);` // 调用**填充构造函数**，创建含 5 个 `100` 的 vector。

##### **2. 成员初始化列表 (Member Initializer Lists) - 高效初始化的正确姿势**

**问题：** 在构造函数函数体 `{}` 内对成员变量赋值是一种低效且在某些情况下行不通的做法。

```cpp
// 低效写法
Vector::Vector() {
    _size = 0; // 这是赋值，不是初始化
}
```

**底层机制：**
1.  **第一步 (隐式初始化):** 在进入函数体 `{}` 前，所有成员变量已被**默认初始化**。
2.  **第二步 (显式赋值):** 在函数体 `{}` 内，用新值**覆盖**已有的值。

这造成了“构造+赋值”的两次操作，对于复杂类成员（如 `std::string`）开销巨大。

**解决方案：** 使用成员初始化列表。

```cpp
// 高效、正确的写法
Vector::Vector() : _size(0), _capacity(4), _data(new T[4]) { }
```

**优点：**
*   **高效：** 直接调用成员变量的构造函数进行**一次性初始化**，避免了默认构造和赋值的开销。
*   **必需：** 对于以下两种成员变量，**必须**使用初始化列表：
    *   **`const` 常量成员：** 必须在定义时初始化，之后无法赋值。
    *   **引用 (`&`) 成员：** 必须在定义时绑定到另一个对象，不能事后赋值。

---

#### **三、 拷贝控制：拷贝、移动与销毁**

##### **1. 区分拷贝构造与拷贝赋值**

这是 C++ 初学者常见的混淆点，但区别非常关键：

*   **拷贝构造函数 (`Widget w2 = w1;`)**:
    *   **时机：** 当使用一个已存在的对象 (`w1`) 来**创建并初始化一个全新的对象** (`w2`) 时调用。
    *   **本质：** 初始化 (Initialization)。

*   **拷贝赋值运算符 (`w2 = w1;`)**:
    *   **时机：** 当将一个已存在的对象 (`w1`) 赋值给**另一个已经存在的对象** (`w2`) 时调用。
    *   **本质：** 赋值 (Assignment)。

##### **2. 默认行为的陷阱：浅拷贝 (Shallow Copy)**

当编译器自动生成拷贝函数时，它执行的是**按成员复制 (member-wise copy)**，即简单地将每个成员变量的值从源对象复制到目标对象。

**问题场景：当类中包含裸指针管理动态内存时。**

```cpp
// 默认拷贝构造函数执行的浅拷贝
new_vector._data = old_vector._data;
```
*   **后果：**
    1.  **指针共享：** 新旧两个对象的指针指向了**同一块**堆内存。
    2.  **意外修改：** 修改一个对象的数据会影响另一个，破坏了对象的独立性。
    3.  **双重释放 (Double Free)：** 两个对象在析构时会尝试释放**同一块**内存，导致程序崩溃。

##### **3. 正确的解决方案：深拷贝 (Deep Copy)**

为了解决浅拷贝的问题，我们需要手动**重写 (override)** 拷贝构造函数和拷贝赋值运算符，以实现深拷贝。

**深拷贝的步骤：**
1.  **为新对象分配独立的内存空间。**
2.  **将原始对象所指向内存中的内容，逐一复制到新分配的空间中。**

```cpp
// 正确的深拷贝实现
Vector::Vector(const Vector& other) 
    : _size(other._size), _capacity(other._capacity), _data(new T[other._capacity]) { // 1. 分配新内存
    for (size_t i = 0; i < _size; ++i) {
        _data[i] = other._data[i]; // 2. 复制内容
    }
}
```

---

#### **四、 精细控制：禁止拷贝与移动语义**

##### **1. 禁止拷贝 (`= delete`)**

在某些场景下，类的对象在逻辑上就不应该被复制（如密码管理器 `PasswordManager`，文件句柄 `FileHandle`）。我们可以通过 C++11 的 `= delete` 语法来显式地禁用拷贝功能。

```cpp
class NonCopyable {
public:
    NonCopyable(const NonCopyable&) = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
};
```
这样任何尝试拷贝 `NonCopyable` 对象的代码都会在编译时报错。

##### **2. 移动语义 (`T&&` 与 `std::move`)**

*   **右值引用 (`T&&`)**: C++11 引入，专门用于绑定到**即将销毁的临时对象（右值）**。它的出现使得我们可以重载函数，为临时对象提供特殊的、更高效的处理逻辑。

*   **移动构造/赋值**: 接受右值引用的构造函数/赋值运算符。它们的核心思想不是“复制”，而是“窃取”或“转移”资源。它们将临时对象的内部资源（如指针）直接转移到新对象中，并将临时对象置为空状态，避免了昂贵的深拷贝。

*   **`std::unique_ptr`**: 是独占所有权的完美范例。它**禁止拷贝**（通过 `= delete` 拷贝构造/赋值），但**允许移动**，清晰地表达了“资源只能有一个主人，但主人可以将所有权转让给下一个人”的语义。

---

#### **五、 类设计的现代哲学：三/五/零法则**

##### **1. 三法则 (Rule of Three) - C++98/03 时代**
如果你的类需要以下三者中的**任何一个**：
1.  自定义析构函数 (通常因为需要释放动态内存)
2.  自定义拷贝构造函数
3.  自定义拷贝赋值运算符

那么你**几乎肯定需要同时实现这三个**，以确保正确的资源管理和深拷贝行为。

##### **2. 五法则 (Rule of Five) - C++11 时代**
三法则的扩展。如果你实现了上述三个，那么你也应该考虑实现另外两个：
4.  移动构造函数
5.  移动赋值运算符

以提供高效的移动语义，并确保在移动操作中正确地处理资源所有权的转移。

##### **3. 零法则 (Rule of Zero) - 现代 C++ 的最佳实践**

**核心思想：**
> **优先设计不需要你手动编写任何特殊成员函数的类。**

**如何实现：**
*   **不要直接使用裸指针管理资源。**
*   **将资源管理委托给行为良好的 RAII (Resource Acquisition Is Initialization) 类。**

**实践：**
使用标准库提供的资源管理工具作为你的成员变量，例如：
*   用 `std::vector` 或 `std::string` 管理动态数组/字符串。
*   用 `std::unique_ptr` 或 `std::shared_ptr` 管理单个堆对象。

**示例：**
```cpp
// 遵守“零法则”的类
class MyGoodClass {
private:
    int id;
    std::string name; // std::string 知道如何自我管理
    std::unique_ptr<Data> data_ptr; // unique_ptr 知道如何自我管理
    
    // 不需要写任何特殊成员函数！
    // 编译器生成的默认版本会完美工作，因为它会
    // 自动调用每个成员的对应特殊函数。
};
```

**结论：** “零法则”是目标。当你无法实现它，被迫要手动管理资源时，才退而求其次地遵循“五法则”。
